/*
 * Copyright 2002-2008 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.integration.jdbc;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.beans.DirectFieldAccessor;
import org.springframework.jdbc.core.namedparam.BeanPropertySqlParameterSource;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.SqlParameterSource;

/**
 * A default implementation of {@link SqlParamterSourceFactory} which creates an
 * {@link SqlParameterSource} according to the result of the polled data passed
 * in
 * 
 * Where the result of the poll is a List a list of ids  generated by looking for 
 * a map entry or bean property named by default 'id'.  The resulting {@link SqlParameterSource}
 * contains this list under a default key of 'idList'.
 * 
 * Where the result of the poll is a {@link Map} this is wrapped in an instance of {@link MapSqlParameterSource}
 * Otherwise the result is wrapped in an instance of {@link BeanPropertySqlParameterSource}
 * 
 * @author Jonas Partner
 * 
 */
public class DefaultSqlParamterSourceFactory implements
		SqlParamterSourceFactory {

	private final Log logger = LogFactory.getLog(getClass());

	private final Map<String, Object> staticParameters;

	private volatile String polledRowIdName = "id";

	private volatile String updateIdsParamName = "idList";

	public DefaultSqlParamterSourceFactory() {
		this.staticParameters = Collections
				.unmodifiableMap(new HashMap<String, Object>());
	}

	public DefaultSqlParamterSourceFactory(Map<String, Object> staticParameters) {
		this.staticParameters = Collections.unmodifiableMap(staticParameters);
	}

	public SqlParameterSource createParamterSource(Object resultOfSelect) {
		SqlParameterSource toReturn;
		if (resultOfSelect instanceof List) {
			List<Object> ids = new ArrayList<Object>();
			for (Object rowObj : (List) resultOfSelect) {
				if (rowObj instanceof Map) {
					ids.add(((Map) rowObj).get(this.polledRowIdName));
				} else {
					DirectFieldAccessor accessor = new DirectFieldAccessor(
							rowObj);
					if (accessor.isReadableProperty(this.polledRowIdName)) {
						ids
								.add(accessor
										.getPropertyValue(this.polledRowIdName));
					} else {
						logger
								.warn("No id field named "
										+ this.polledRowIdName
										+ " found for result of polled row.  Update may not include all rows");
					}
				}
			}
			MapSqlParameterSource thisParamSource = new MapSqlParameterSource();
			if (this.staticParameters != null) {
				thisParamSource.addValues(this.staticParameters);
			}
			thisParamSource.addValue(this.updateIdsParamName, ids);
			thisParamSource.getValue("idList");
			toReturn = thisParamSource;
		} else if (resultOfSelect instanceof Map) {
			MapSqlParameterSource mapParameterSource = new MapSqlParameterSource(
					(Map) resultOfSelect);
			mapParameterSource.addValues(this.staticParameters);
			toReturn = mapParameterSource;
		} else {
			BeanPropertySqlParameterSource beanParameterSource = new BeanPropertySqlParameterSource(
					resultOfSelect);
			toReturn = beanParameterSource;
		}
		return toReturn;
	}

}
