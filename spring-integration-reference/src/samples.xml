<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<appendix id="samples">
  <title>Spring Integration Samples</title>

  <section id="samples-cafe">
    <title>The Cafe Sample</title>
    <para>
      In this section, we will review a sample application that is included in the Spring Integration
      distribution. This sample is inspired by one of the samples featured in Gregor Hohpe's
      <ulink url="http://www.eaipatterns.com/ramblings.html">Ramblings</ulink>.
    </para>
    <para>
      The domain is that of a Cafe, and the basic flow is depicted in the following diagram:
    </para>
    <para>
      <mediaobject>
        <imageobject>
          <imagedata align="center" fileref="images/cafe-demo.png" format="PNG"/>
        </imageobject>
      </mediaobject>
    </para>
    <para>
      The <classname>Order</classname> object may contain multiple <classname>OrderItems</classname>. Once the order
      is placed, a <emphasis>Splitter</emphasis> will break the composite order message into a single message per
      drink. Each of these is then processed by a <emphasis>Router</emphasis> that determines whether the drink is hot
      or cold (checking the <classname>OrderItem</classname> object's 'isIced' property). Finally the
      <classname>Barista</classname> prepares each drink, but hot and cold drink preparation are handled by two
      distinct methods: 'prepareHotDrink' and 'prepareColdDrink'. The prepared drinks are then sent to the Waiter where
      they are aggregated into a <classname>Delivery</classname> object.
    </para>
    <para>
      Here is the XML configuration:
      <programlisting language="xml"><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<beans:beans xmlns="http://www.springframework.org/schema/integration"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:beans="http://www.springframework.org/schema/beans"
    xmlns:stream="http://www.springframework.org/schema/integration/stream"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
            http://www.springframework.org/schema/integration
            http://www.springframework.org/schema/integration/spring-integration-1.0.xsd
            http://www.springframework.org/schema/integration/stream
            http://www.springframework.org/schema/integration/stream/spring-integration-stream-1.0.xsd">

    <message-bus/>

    <gateway id="cafe" service-interface="org.springframework.integration.samples.cafe.Cafe"/>

    <channel id="orders"/>
    <splitter input-channel="orders" ref="orderSplitter" method="split" output-channel="drinks"/>

    <channel id="drinks"/>
    <router input-channel="drinks" ref="drinkRouter" method="resolveOrderItemChannel"/>

    <channel id="coldDrinks">
        <queue capacity="10"/>
    </channel>
    <service-activator input-channel="coldDrinks" ref="barista"
                       method="prepareColdDrink" output-channel="preparedDrinks"/>

    <channel id="hotDrinks">
        <queue capacity="10"/>
    </channel>
    <service-activator input-channel="hotDrinks" ref="barista"
                       method="prepareHotDrink" output-channel="preparedDrinks"/>

    <channel id="preparedDrinks"/>
    <aggregator input-channel="preparedDrinks" ref="waiter"
                method="prepareDelivery" output-channel="deliveries"/>

    <stream:stdout-channel-adapter id="deliveries"/>

    <beans:bean id="orderSplitter"
                class="org.springframework.integration.samples.cafe.xml.OrderSplitter"/>

    <beans:bean id="drinkRouter"
                class="org.springframework.integration.samples.cafe.xml.DrinkRouter"/>

    <beans:bean id="barista" class="org.springframework.integration.samples.cafe.xml.Barista"/>

    <beans:bean id="waiter" class="org.springframework.integration.samples.cafe.xml.Waiter"/>

</beans:beans>]]></programlisting>
      Notice that the Message Bus is defined. It will automatically detect and register all channels and endpoints,
      and it will manage the Lifecycle for each endpoint. Notice that the objects are simple POJOs with strongly
      typed method arguments. For example, here is the Splitter.
      <programlisting language="java"><![CDATA[public class OrderSplitter {

    public List<OrderItem> split(Order order) {
        return order.getItems();
    }
}]]></programlisting>
    In the case of the Router, the return value does not have to be a <interfacename>MessageChannel</interfacename>
    instance (although it can be). As you see in this example, a String-value representing the channel name is
    returned instead.
    <programlisting language="java"><![CDATA[public class DrinkRouter {

    public String resolveOrderItemChannel(OrderItem orderItem) {
        return (orderItem.isIced()) ? "coldDrinks" : "hotDrinks";
    }
}]]></programlisting>
    </para>
    <para>
      Now turning back to the XML, you see that there are two &lt;service-activator&gt; elements. Each of these
      is delegating to the same <classname>Barista</classname> instance but different methods: 'prepareHotDrink'
      or 'prepareColdDrink' corresponding to the two channels where order items have been routed.
      <programlisting language="java"><![CDATA[public class Barista {

    private long hotDrinkDelay = 5000;
    private long coldDrinkDelay = 1000;

    private AtomicInteger hotDrinkCounter = new AtomicInteger();
    private AtomicInteger coldDrinkCounter = new AtomicInteger();

    public void setHotDrinkDelay(long hotDrinkDelay) {
        this.hotDrinkDelay = hotDrinkDelay;
    }

    public void setColdDrinkDelay(long coldDrinkDelay) {
        this.coldDrinkDelay = coldDrinkDelay;
    }

    public Drink prepareHotDrink(OrderItem orderItem) {
        try {
            Thread.sleep(this.hotDrinkDelay);
            System.out.println(Thread.currentThread().getName()
                    + " prepared hot drink #" + hotDrinkCounter.incrementAndGet()
                    + " for order #" + orderItem.getOrder().getNumber() + ": " + orderItem);
            return new Drink(orderItem.getOrder().getNumber(), orderItem.getDrinkType(),
                    orderItem.isIced(), orderItem.getShots());
        }
        catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return null;
        }
    }

    public Drink prepareColdDrink(OrderItem orderItem) {
        try {
            Thread.sleep(this.coldDrinkDelay);
            System.out.println(Thread.currentThread().getName()
                    + " prepared cold drink #" + coldDrinkCounter.incrementAndGet()
                    + " for order #" + orderItem.getOrder().getNumber() + ": " + orderItem);
            return new Drink(orderItem.getOrder().getNumber(), orderItem.getDrinkType(),
                    orderItem.isIced(), orderItem.getShots());
        }
        catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return null;
        }
    }

}]]></programlisting>
    </para>
    <para>
      As you can see from the code excerpt above, the barista methods have different delays (the hot drinks take 5
      times as long to prepare). This simulates work being completed at different rates. When the
      <classname>CafeDemo</classname> 'main' method runs, it will loop 100 times sending a single hot drink and a
      single cold drink each time. It actually sends the messages by invoking the 'placeOrder' method on the Cafe
      interface. Above, you will see that the &lt;gateway&gt; element is specified in the configuration file. This
      triggers the creation of a proxy that implements the given 'service-interface' and connects it to a channel.
      The channel name is provided on the @Gateway annotation of the <interfacename>Cafe</interfacename> interface.
      <programlisting language="java">public interface Cafe {

    @Gateway(requestChannel="orders")
    void placeOrder(Order order);

}</programlisting>
      Finally, have a look at the <methodname>main()</methodname> method of the <classname>CafeDemo</classname> itself.
      <programlisting language="java"><![CDATA[public static void main(String[] args) {
    AbstractApplicationContext context = null;
    if (args.length > 0) {
        context = new FileSystemXmlApplicationContext(args);
    }
    else {
        context = new ClassPathXmlApplicationContext("cafeDemo.xml", CafeDemo.class);
    }
    Cafe cafe = (Cafe) context.getBean("cafe");
    for (int i = 1; i <= 100; i++) {
        Order order = new Order(i);
        order.addItem(DrinkType.LATTE, 2, false);
        order.addItem(DrinkType.MOCHA, 3, true);
        cafe.placeOrder(order);
    }
}]]></programlisting>
    </para>
    <para>
      To run this demo, go to the "samples" directory within the root of the Spring Integration distribution. On
      Unix/Mac you can run 'cafeDemo.sh', and on Windows you can run 'cafeDemo.bat'. Each of these will by default
      create a Spring <interfacename>ApplicationContext</interfacename> from the 'cafeDemo.xml' file that is
      in the "spring-integration-samples" JAR and hence on the classpath (it is the same as the XML above). However, a
      copy of that file is also available within the "samples" directory, so that you can provide the file name as a
      command line argument to either 'cafeDemo.sh' or 'cafeDemo.bat'. This will allow you to experiment with the
      configuration and immediately run the demo with your changes. It is probably a good idea to first copy the
      original file so that you can make as many changes as you want and still refer back to the original to compare.
    </para>
    <para>
      When you run cafeDemo, you will see that the cold drinks are initially prepared more quickly than the hot drinks.
      Because there is an aggregator, the cold drinks are effectively limited by the rate of the hot drink preparation.
      This is to be expected based on their respective delays of 1000 and 5000 milliseconds. However, by configuring a
      poller with a concurrent task executor, you can dramatically change the results. For example, you could use a
      thread pool executor with 5 workers for the hot drink barista while keeping the cold drink barista as it is:
      <programlisting language="xml"><![CDATA[<service-activator input-channel="hotDrinks"
                   ref="barista"
                   method="prepareHotDrink"
                   output-channel="preparedDrinks"/>

<service-activator input-channel="hotDrinks"
                   ref="barista"
                   method="prepareHotDrink"
                   output-channel="preparedDrinks">
    ]]><emphasis><![CDATA[<poller task-executor="pool">
        <interval-trigger interval="1000"/>
    </poller>]]></emphasis><![CDATA[
</service-activator>

]]><emphasis><![CDATA[<thread-pool-task-executor id="pool" core-size="5"/>]]></emphasis></programlisting>
    </para>
    <para>
      Also, notice that the worker thread name is displayed with each invocation. You will see that the hot drinks are
      prepared by the task-executor threads. If you provide a much shorter poller interval (such as 100 milliseconds),
      then you will notice that occasionally it throttles the input by forcing the message-bus (the caller) to invoke
      the operation.
    </para>
    <para>
      In addition to experimenting with the poller's concurrency settings, you can also add the 'transactional'
      sub-element as described in <xref linkend="namespace-endpoint"/>. If you want to explore the sample in more
      detail, the source JAR is available in the "src" directory:
      'org.springframework.integration.samples-sources-1.0.0.RC1.jar'.
    </para>
  </section>
</appendix>