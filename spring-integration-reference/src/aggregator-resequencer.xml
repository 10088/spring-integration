<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter>
  <title>Aggregation and Resequencing</title>

  <section>
    <title>Introduction</title>

    <para>Basically a mirror-image of the Splitter, the Aggregator is a type
    of Message Consumer that receives multiple Messages and combines them into
    a single Message. In fact, Aggregators are often downstream consumers in a
    pipeline that includes a Splitter.</para>

    <para>Technically, the Aggregator is more complex than a Splitter, because
    it is required to maintain state (the Messages to-be-aggregated), to
    decide when the complete group of Messages is available, and to timeout if
    necessary. Furthermore, in case of a timeout, the Aggregator needs to know
    whether to send the partial results or to discard them to a separate
    channel.</para>

    <para>Related to the Aggregator, albeit different from a functional
    standpoint, is the Resequencer. In this chapter, we will treat them
    together because of their similar functionalities.</para>
  </section>

  <section>
    <title>Functionality</title>

    <section>
      <title>Aggregation</title>

      <para>The Aggregator combines a group of related messages, by storing
      and grouping them, until the group is deemed complete. At that point,
      the Aggregator will create a single message by processing the whole
      group, and will send the result message further.</para>

      <para>As messages might arrive with a certain delay (or certain messages
      from the group might not arrive at all), the Aggregator can specify a
      timeout (counted from the moment when the first message in the group has
      arrived), and whether, in the case of a timeout, the group should be
      discarded, or the Aggregator should merely attempt to create a single
      message out of what has arrived so far. An important aspect of
      implementing an Aggregator is providing the logic that has to be
      executed when the aggregation (creation of a single message out of many)
      takes place.</para>

      <para>In Spring Integration, the grouping of the messages for
      Aggregation is done based on their CORRELATION_ID message header (i.e.
      the messages with the same CORRELATION_ID will be grouped
      together).</para>

      <para>An important concern with respect to the timeout is, what happens
      if late messages arrive after the aggregation has taken place? In this
      case, a configuration option allows the user to decide whether they
      should be discarded or not.</para>
    </section>

    <section>
      <title>Resequencing</title>

      <para>The Resequencer works in a similar way to the Aggregator, in the
      sense that it uses the CORRELATION_ID to store messages in groups, the
      difference being that all what the Resequencer does, is to release them
      in the order of their SEQUENCE_NUMBER.</para>

      <para>With respect to that, the user might opt to release all messages
      at once (after the whole sequence, according to the SEQUENCE_SIZE, has
      been released), or as soon as a valid sequence is available. Another
      option is to set a timeout, deciding whether to drop the whole sequence
      if the timeout has expired, and not all messages have arrived, or to
      release the messages accumulated so far, in the appropriate
      order.</para>
    </section>
  </section>

  <section>
    <title>The API</title>

    <para></para>

    <section>
      <title>Programming with Aggregator</title>

      <para>The Aggregation API consists of a number of classes:</para>

      <itemizedlist>
        <listitem>
          <para>The base class <code>AbstractMessageAggregator </code>and its
          subclass <code>MethodInvokingMessageAggregator</code></para>
        </listitem>
      </itemizedlist>

      <itemizedlist>
        <listitem>
          <para>The <code>CompletionStrategy</code> interface and its default
          implementation <code>SequenceSizeCompletionStrategy</code></para>
        </listitem>
      </itemizedlist>

      <para>The <code>AbstractMessageAggregator</code> is a
      <code>MessageConsumer</code> implementation, encapsulating the common
      functionalities of an Aggregator, which are: storing messages until the
      message sequence to aggregate is complete (and grouping them according
      to their CORRELATION_ID), and implementing the timeout functionality.
      The responsibility of deciding whether the message sequence is complete
      is delegated to a <code>CompletionStrategy</code> instance.</para>

      <para>A brief highlight of the base
      <code>AbstractMessageAggregator</code> (the responsibility of
      implementing the aggregateMessages method is left to the
      developer):</para>

      <programlisting language="java">public abstract class AbstractMessageAggregator extends AbstractMessageBarrierConsumer {

  private volatile CompletionStrategy completionStrategy
                            = new SequenceSizeCompletionStrategy();
  ....

  protected abstract Message&lt;?&gt; aggregateMessages(List&lt;Message&lt;?&gt;&gt; messages);

}</programlisting>

      <para>For implementing a specific aggregator object for an application,
      a developer can extend <code>AbstractMessageAggregator </code>and
      implement the <code>aggregateMessages</code> method. However, there are
      better suited (which reads, less coupled to the API) solutions for
      implementing the aggregation logic, which can be configured easily
      either through XML or through annotations.</para>

      <para><note>
          <para>In the interest of code simplicity, and promoting best
          practices such as low coupling, testability, etc., the preferred way
          of implementing the aggregation logic is by implementing a POJO, and
          using the XML or annotation support for setting it up in the
          application.</para>
        </note>The <code>CompletionStrategy</code> interface is defined as
      follows:</para>

      <programlisting language="java">public interface CompletionStrategy {

  boolean isComplete(List&lt;Message&lt;?&gt;&gt; messages);

}</programlisting>

      <para>Spring Integration provides an out-of-the box implementation for
      <code>CompletionStrategy</code>, the
      <code>SequenceSizeCompletionStrategy</code> This implementation uses the
      SEQUENCE_NUMBER and SEQUENCE_SIZE of the arriving messages for deciding
      when a message group is complete and ready to be
      aggregated.<code></code></para>
    </section>
  </section>

  <section>
    <title>Configuration using XML</title>

    <section>
      <title>Configuring an aggregator through XML</title>

      <para>Spring Integration supports the configuration of an aggregator via
      XML through the &lt;aggregator/&gt; element. A completely defined sample
      on how to define such an element is presented below, as well as
      it:</para>

      <programlisting>&lt;aggregator id="completelyDefinedAggregator" <co
          id="aggxml1" />
    input-channel="completelyDefinedAggregatorInput" <co id="aggxml2" />
    output-channel="outputChannel"  <co id="aggxml3" />
    discard-channel="discardChannel"  <co id="aggxml4" />
    ref="aggregatorBean" <co id="aggxml5" />
    method="add" <co id="aggxml6" />
    completion-strategy="completionStrategy"  <co id="aggxml7" />
    completion-strategy-method="checkCompleteness" <co id="aggxml8" />
    timeout="42" <co id="aggxml9" />
    send-partial-result-on-timeout="true" <co id="aggxml10" />
    reaper-interval="135" <co id="aggxml11" />
    tracked-correlation-id-capacity="99" <co id="aggxml12" />
    send-timeout="86420000" /&gt; <co id="aggxml13" /></programlisting>

      <calloutlist>
        <callout arearefs="aggxml1">
          <para>The id of the aggregator is
          <emphasis>optional</emphasis>.</para>
        </callout>

        <callout arearefs="aggxml2">
          <para>The input channel of the aggregator.
          <emphasis>Required</emphasis>.</para>
        </callout>

        <callout arearefs="aggxml3">
          <para>The channel where the aggregator will send the aggregation
          results. <emphasis>Required</emphasis>.</para>
        </callout>

        <callout arearefs="aggxml4">
          <para>The channel where the aggregator will send the messages that
          timed out (if <code>send-partial-results-on-timeout</code> is
          <emphasis>true</emphasis>. <emphasis>Optional</emphasis>.</para>
        </callout>

        <callout arearefs="aggxml5">
          <para>A reference to a bean defined in the application context. The
          bean must either extend <code>AbstractMessageAggregator</code> or be
          a POJO. In the latter case the <code>method</code> attribute must be
          defined as well. <emphasis>Required</emphasis>.</para>
        </callout>

        <callout arearefs="aggxml6">
          <para>A method defined on the bean referenced by <code>ref</code>,
          <emphasis><emphasis>that implements the message aggregation
          algorithm.</emphasis> Optional, with restrictions (see
          above).</emphasis></para>
        </callout>

        <callout arearefs="aggxml7">
          <para>A reference to a bean that implements the decision algorithm
          as to whether a given message group is complete. The bean can be an
          implementation of the CompletionStrategy interface or a POJO. In the
          latter case the completion-strategy-mTethod attribute must be
          defined as well. Optional.</para>
        </callout>

        <callout arearefs="aggxml8">
          <para>A method defined on the bean referenced by
          <code>completion-strategy</code>, <emphasis><emphasis>that
          implements the completion decision algorithm.</emphasis> Optional,
          with restrictions (see above).</emphasis> Optional.</para>
        </callout>

        <callout arearefs="aggxml9">
          <para>The timeout for aggregating messages (counted from the arrival
          of the first message). Optional.</para>
        </callout>

        <callout arch="" arearefs="aggxml10">
          <para>Whether upon the expiration of the timeout, the aggregator
          shall try to aggregate the already arrived messages.
          <emphasis>Optional (false by default)</emphasis>.</para>
        </callout>

        <callout arearefs="aggxml11" condition="">
          <para>The interval (in milliseconds) at which a reaper task is
          executed, checking if there are any timed out groups.
          Optional.</para>
        </callout>

        <callout arearefs="aggxml12">
          <para>The capacity of the correlation id tracker. Remembers the
          already processed correlation ids, preventing the formation of new
          groups for messages that arrive after their group has been already
          processed (aggregated or discarded). Optional.</para>
        </callout>

        <callout arearefs="aggxml13">
          <para>The timeout for sending out messages. Optional.</para>
        </callout>
      </calloutlist>
    </section>

    <section>
      <title>Configuring a resequencer by using XML</title>

      <para></para>
    </section>
  </section>

  <section>
    <title>Configuration using annotations</title>

    <para></para>
  </section>
</chapter>
